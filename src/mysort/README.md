# 排序

学习方式
- 原理
- 实现
- 如何评价、分析一个排序算法

## 具体排序
- [x] [冒泡](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
- [x] [选择](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
- [x] [插入](https://zh.wikipedia.org/zh-hans/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
- [x] [归并](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
  - [ ] 用哨兵方式简化流程
- [ ] 希尔(可以视为插入排序的优化)
- [ ] [快速](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
- [ ] 基数
- [ ] 计数
- [ ] 堆
- [ ] 桶
## 各种排序算法比较

|排序|时间复杂度|空间复杂度|是否原地| 是否基于比较 | 是否稳定| 思想|技巧| 其他|
|----|---|---|----|---|---|---|---|---|
|冒泡|O(n^2)||是|是|是||||
|插入|O(n^2)||是|是|是||||
|选择|O(n^2)||是|是|否||||
|归并|O(nlogn)|O(n)|否|是|是|分治思想|递归|归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的|
|快排|||是x|是x|是x|分治思想|||

## 问题解答

### 问题一 冒泡与插入时间复杂度一样，实际软件开发中为什么更倾向于使用插入排序？

因冒泡的数据交换比插入的数据交换步骤更多，如下

冒泡数据交换步骤

```go
p[i], p[j] = p[j], p[i]
```

插入排序数据交换步骤

```go
if (a[j] > value) { 
    a[j+1] = a[j]; // 数据移动
}
```

## 归并排序与快速排序区别与联系

### 相同点

- 都是采用分治思想
- 

![](./../pictures/quickSortCmpMergeSort.jpg)